-- Get currently selected unit
function GetSelectedUnit()
  return UI.GetHeadSelectedUnit();
end

-- Get first ready unit for a player
function GetFirstReadyUnit(playerID)
  local pPlayer = Players[playerID];
  if pPlayer then
    return pPlayer:GetUnits():GetFirstReadyUnit();
  end
  return nil;
end

-- Get unit by ID
function GetUnit(playerID, unitID)
  return Players[playerID]:GetUnits():FindID(unitID);
end

-- Get all units in plot
function GetUnitsInPlot(x, y)
  return Units.GetUnitsInPlotLayerID(x, y, MapLayers.ANY);
end

-- Get full unit data including stats
function GetUnitData(unit)
  if unit == nil then return nil end

  local data = {
    Name = unit:GetName(),
    Combat = unit:GetCombat(),
    RangedCombat = unit:GetRangedCombat(),
    BombardCombat = unit:GetBombardCombat(),
    AntiAirCombat = unit:GetAntiAirCombat(),
    Range = unit:GetRange(),
    Damage = unit:GetDamage(),
    MaxDamage = unit:GetMaxDamage(),
    Moves = unit:GetMovesRemaining(),
    MaxMoves = unit:GetMaxMoves(),
    UnitType = unit:GetUnitType(),
    Formation = unit:GetMilitaryFormation(),
    Experience = unit:GetExperience():GetExperiencePoints(),
    Level = unit:GetExperience():GetLevel(),
    Position = {
      X = unit:GetX(),
      Y = unit:GetY()
    }
  };
  return data;
end
-- Get city from plot coordinates
function GetCityInPlot(plotX, plotY)
  return Cities.GetCityInPlot(plotX, plotY);
end

-- Get city by ID
function GetCity(playerID, cityID)
  local pPlayer = Players[playerID];
  if pPlayer then
    return pPlayer:GetCities():FindID(cityID);
  end
  return nil;
end

-- Get district from city
function GetDistrictFromCity(pCity)
  if pCity ~= nil then
    local cityOwner = pCity:GetOwner();
    local districtId = pCity:GetDistrictID();
    local pPlayer = Players[cityOwner];
    if pPlayer ~= nil then
      local pDistrict = pPlayer:GetDistricts():FindID(districtId);
      if pDistrict ~= nil then
        return pDistrict;
      end
    end
  end
  return nil;
end
-- Get plot by index
function GetPlotByIndex(plotID)
  if Map.IsPlot(plotID) then
    return Map.GetPlotByIndex(plotID);
  end
  return nil;
end

-- Get plot from coordinates
function GetPlot(x, y)
  return Map.GetPlot(x, y);
end

-- Get plot ownership
function GetPlotOwner(plot)
  if plot:IsOwned() then
    return plot:GetOwner();
  end
  return -1;
end
-- Get local player
function GetLocalPlayer()
  return Game.GetLocalPlayer();
end

-- Get player visibility data
function GetPlayerVisibility(playerID)
  return PlayersVisibility[playerID];
end

-- Get player colors
function GetPlayerColors(playerID)
  return UI.GetPlayerColors(playerID);
end
-- Get outgoing trade routes from city
function GetCityTradeRoutes(city)
  local routes = {};
  local outgoingRoutes = city:GetTrade():GetOutgoingRoutes();
  for i, route in ipairs(outgoingRoutes) do
    routes[#routes+1] = {
      OriginCityID = route.OriginCityID,
      DestinationCityID = route.DestinationCityID,
      TraderUnitID = route.TraderUnitID
    };
  end
  return routes;
end
-- Get combat simulation results
function GetCombatResults(attackerID, targetX, targetY)
  return CombatManager.SimulateAttackInto(attackerID, nil, targetX, targetY);
end

-- Check if can attack target
function CanAttackTarget(attackerID, defenderID)
  local eCombatType = CombatTypes.MELEE;
  return CombatManager.CanAttackTarget(attackerID, defenderID, eCombatType);
end
-- Get available operations for unit
function GetAvailableOperations(unit)
  local operations = {};
  for operation in GameInfo.UnitOperations() do
    local canStart = UnitManager.CanStartOperation(unit, operation.Hash, true);
    if canStart then
      operations[#operations+1] = operation;
    end
  end
  return operations;
end

-- Get available promotions for unit
function GetAvailablePromotions(unit)
  local bCanStart, tResults = UnitManager.CanStartCommand(
    unit,
    UnitCommandTypes.PROMOTE,
    true,
    nil,
    true
  );
  if bCanStart and tResults then
    return tResults[UnitCommandResults.PROMOTIONS];
  end
  return nil;
end
Getting government info:
local playerID = Game.GetLocalPlayer()
local player = Players[playerID]
local playerCulture = player:GetCulture()

-- Get current government
local currentGovernmentIndex = playerCulture:GetCurrentGovernment()
local currentGovernment = GameInfo.Governments[currentGovernmentIndex]

-- Check if a specific government is unlocked
local governmentHash = GameInfo.Governments["GOVERNMENT_AUTOCRACY"].Hash
local isUnlocked = playerCulture:IsGovernmentUnlocked(governmentHash)
Getting city yields and info:
local pCity = player:GetCities():GetCapitalCity() -- or any other city

-- Get basic yields
local foodYield = Round(pCity:GetYield(YieldTypes.FOOD), 1)
local productionYield = Round(pCity:GetYield(YieldTypes.PRODUCTION), 1)
local goldYield = Round(pCity:GetYield(YieldTypes.GOLD), 1)
local scienceYield = Round(pCity:GetYield(YieldTypes.SCIENCE), 1)
local cultureYield = Round(pCity:GetYield(YieldTypes.CULTURE), 1)
local faithYield = Round(pCity:GetYield(YieldTypes.FAITH), 1)

-- Get yield tooltips (shows breakdown)
local foodTooltip = pCity:GetYieldToolTip(YieldTypes.FOOD)

-- Get Growth Info
local pCityGrowth = pCity:GetGrowth()
local housing = pCityGrowth:GetHousing()
local amenities = pCityGrowth:GetAmenities()
local foodSurplus = pCityGrowth:GetFoodSurplus()

Building info:
local pCityBuildings = pCity:GetBuildings()

-- Check if a building exists
local buildingType = "BUILDING_GRANARY"
local buildingIndex = GameInfo.Buildings[buildingType].Index
local hasBuilding = pCityBuildings:HasBuilding(buildingIndex)

-- Check if building is pillaged
local isPillaged = pCityBuildings:IsPillaged(buildingType)

-- Get building yields
local buildingYield = pCity:GetBuildingYield(buildingType, "YIELD_FOOD")

-- Get all buildings in a plot
local plotID = someplot:GetIndex()
local buildingTypes = pCityBuildings:GetBuildingsAtLocation(plotID)
for _, buildingType in ipairs(buildingTypes) do
    local building = GameInfo.Buildings[buildingType]
    -- building.Name, building.BuildingType, etc.
end
District info:
local pCityDistricts = pCity:GetDistricts()

-- Check if district exists
local districtType = "DISTRICT_CAMPUS"
local hasDistrict = pCityDistricts:HasDistrict(GameInfo.Districts[districtType].Index)

-- Get district yields
for i, district in pCityDistricts:Members() do
    local districtInfo = GameInfo.Districts[district:GetType()]
    local scienceYield = district:GetYield(YieldTypes.SCIENCE)
    local isPillaged = pCityDistricts:IsPillaged(district:GetType())
end

Building.district hash ids:
-- Get building hash
local buildingHash = GameInfo.Buildings["BUILDING_GRANARY"].Hash

-- Get district hash
local districtHash = GameInfo.Districts["DISTRICT_CAMPUS"].Hash

-- Lookup by hash
local buildingType = GameInfo.Buildings[buildingHash].BuildingType

This is the error we are getting, it seems like civ6obv is not getting imported correctly, but also, the rl environment script loads before the syntax error, so maybe we gotta fix order ontop of fixing syntax error?

 Rl_enviroment_scripts: Error: Failed to load civ6obv. Check file path and make sure the file exists.
 Rl_enviroment_scripts: RLv1: Initializing agent for player: 0
 Rl_enviroment_scripts: RLv1: Agent initialized successfully!
 Rl_enviroment_scripts: RLv1: Script loaded!
 Syntax Error: C:\Users\Johan\Documents\My Games\Sid Meier's Civilization VI\Mods\RLv1\civ6obv.lua:503: "=" or "," expected near '<eof>'
 Runtime Error: C:\Program Files (x86)\Steam\steamapps\common\Sid Meier's Civilization VI\Base\Assets\UI\Colors.lua:6: attempt to index a nil value
stack traceback:
	C:\Program Files (x86)\Steam\steamapps\common\Sid Meier's Civilization VI\Base\Assets\UI\Colors.lua:6: in function '(main chunk)'
	[C]: in function 'lInclude'
	C:\Program Files (x86)\Steam\steamapps\common\Sid Meier's Civilization VI\Base\Assets\UI\Civ6Common.lua:6: in function '(main chunk)'
	[C]: in function 'lInclude'
	C:\Users\Johan\Documents\My Games\Sid Meier's Civilization VI\Mods\RLv1\civ6actions.lua:4: in function '(main chunk)'
	[C]: in function '(anonymous)'
Lua callstack:

@C:\Program Files (x86)\Steam\steamapps\common\Sid Meier's Civilization VI\Base\Assets\UI\Civ6Common.lua:6
@C:\Users\Johan\Documents\My Games\Sid Meier's Civilization VI\Mods\RLv1\civ6actions.lua:4
 Runtime Error: C:\Users\Johan\Documents\My Games\Sid Meier's Civilization VI\Mods\RLv1\civ6actions.lua:15: attempt to index a nil value
stack traceback:
	C:\Users\Johan\Documents\My Games\Sid Meier's Civilization VI\Mods\RLv1\civ6actions.lua:15: in function '(main chunk)'
	[C]: in function '(anonymous)'




How to choose a civic: 
Example of choosing a civic, given a civic hash
local playerID = Game.GetLocalPlayer()
local player = Players[playerID]
local playerCulture = player:GetCulture()
local availableCivics = GetData() -- Returns table of available civics
--choose a civic from availables
local chosenCivic = availableCivics[index] -- Pick civic from the data
local civicHash = chosenCivic.Hash
local params = {}
params[PlayerOperations.PARAM_CIVIC_TYPE] = civicHash
params[PlayerOperations.PARAM_INSERT_MODE] = PlayerOperations.VALUE_EXCLUSIVE
UI.RequestPlayerOperation(Game.GetLocalPlayer(), PlayerOperations.PROGRESS_CIVIC, params)
How to choose a tech:
local playerID = Game.GetLocalPlayer()
local player = Players[playerID]
local playerTechs = player:GetTechs()
local availableTechs = GetData() -- Returns table of available techs
--choose tech here
local chosenTech = availableTechs[index] -- Pick tech from the data
local techHash = chosenTech.Hash
local params = {}
params[PlayerOperations.PARAM_TECH_TYPE] = techHash
params[PlayerOperations.PARAM_INSERT_MODE] = PlayerOperations.VALUE_EXCLUSIVE
UI.RequestPlayerOperation(Game.GetLocalPlayer(), PlayerOperations.RESEARCH, params)
How to end a turn:
-- Basic end turn
UI.RequestAction(ActionTypes.ACTION_ENDTURN)

-- Force end turn (bypass blockers)
UI.RequestAction(ActionTypes.ACTION_ENDTURN, true) -- Shift + Enter equivalent
City Ranged attack:
local playerID = Game.GetLocalPlayer()
local player = Players[playerID]
local attackCity = player:GetCities():GetFirstRangedAttackCity()

if attackCity then
    -- Look at and select the city
    UI.LookAtPlot(attackCity:GetX(), attackCity:GetY())
    -- Trigger the range strike mode/interface
    LuaEvents.CQUI_CityRangeStrike(playerID, attackCity:GetID())
end

Encampment ranged attack:
local playerID = Game.GetLocalPlayer()
local player = Players[playerID]

-- Find first encampment that can attack
local function GetFirstRangedAttackEncampment()
    for i, district in player:GetDistricts():Members() do
        if CityManager.CanStartCommand(district, CityCommandTypes.RANGE_ATTACK) then
            return district
        end
    end
    return nil
end

local attackEncampment = GetFirstRangedAttackEncampment()
if attackEncampment then
    -- Look at and select the district
    UI.LookAtPlot(attackEncampment:GetX(), attackEncampment:GetY())
    -- Trigger the range strike mode/interface
    LuaEvents.CQUI_DistrictRangeStrike(playerID, attackEncampment:GetID())
end
Validation before end turn:
local player = Players[Game.GetLocalPlayer()]
if player and not player:IsTurnActiveComplete() and not UI.IsProcessingMessages() then
    -- Safe to end turn
end
Before ranged attacks validation:
-- Check if ranged attacks are enabled
local canRangeAttack = UserConfiguration.IsCityRangeAttackTurnBlocking() and 
                       Game.IsAllowTacticalCommands(Game.GetLocalPlayer())

-- For cities specifically
local notification = NotificationManager.FindType(
    NotificationTypes.CITY_RANGE_ATTACK, 
    Game.GetLocalPlayer()
)
if notification and not notification:IsDismissed() then
    -- Can do city ranged attack
end
Send envoy: 
local playerID = Game.GetLocalPlayer() 
local parameters = {}
parameters[PlayerOperations.PARAM_PLAYER_ONE] = cityStateID -- target city state
UI.RequestPlayerOperation(playerID, PlayerOperations.GIVE_INFLUENCE_TOKEN, parameters)
Make pace with city state
local playerID = Game.GetLocalPlayer()
local parameters = {}
parameters[PlayerOperations.PARAM_PLAYER_ONE] = playerID 
parameters[PlayerOperations.PARAM_PLAYER_TWO] = cityStateID
UI.RequestPlayerOperation(playerID, PlayerOperations.DIPLOMACY_MAKE_PEACE, parameters)
Levy military
local playerID = Game.GetLocalPlayer()
local parameters = {}
parameters[PlayerOperations.PARAM_PLAYER_ONE] = cityStateID
UI.RequestPlayerOperation(playerID, PlayerOperations.LEVY_MILITARY, parameters)
Envoy check:
local pPlayer = Players[Game.GetLocalPlayer()]
local pInfluence = pPlayer:GetInfluence()
-- Check if can give influence
if pInfluence:CanGiveInfluence() then
    -- Check tokens available 
    local envoyTokens = pInfluence:GetTokensToGive()
    -- Check if city state can receive tokens
    if pInfluence:CanGiveTokensToPlayer(cityStateID) then
        -- Safe to give influence
    end
end
Peace:
local pPlayer = Players[Game.GetLocalPlayer()]
-- Check if can make peace
if pPlayer:GetDiplomacy():CanMakePeaceWith(cityStateID) then
    -- Safe to make peace
end
Levy Military:
local pPlayer = Players[Game.GetLocalPlayer()]
-- Check if can levy military
if pPlayer:GetInfluence():CanLevyMilitary(cityStateID) then
    -- Get levy cost
    local cost = pPlayer:GetInfluence():GetLevyMilitaryCost(cityStateID)
    -- Get how long levy lasts
    local turnLimit = Players[cityStateID]:GetInfluence():GetLevyTurnLimit()
    -- Safe to levy if player can afford cost
end
Get Suzerain (controlling player): pInfluence:GetSuzerain()
Check if at war: pPlayer:GetDiplomacy():IsAtWarWith(cityStateID)
Get envoys given: pInfluence:GetTokensReceived(cityStateID)
Get quests: GetQuests(cityStateID)
Get bonuses provided: GetBonusText(cityStateID, envoyLevel)
Get relationships: GetRelationships(cityStateID)

Recruit a great person: 
local playerID = Game.GetLocalPlayer()
local parameters = {}
parameters[PlayerOperations.PARAM_GREAT_PERSON_INDIVIDUAL_TYPE] = individualID 
UI.RequestPlayerOperation(playerID, PlayerOperations.RECRUIT_GREAT_PERSON, parameters)
Reject a great person:
local playerID = Game.GetLocalPlayer()
local parameters = {}
parameters[PlayerOperations.PARAM_GREAT_PERSON_INDIVIDUAL_TYPE] = individualID
UI.RequestPlayerOperation(playerID, PlayerOperations.REJECT_GREAT_PERSON, parameters)

Patronize gold:
local playerID = Game.GetLocalPlayer()
local parameters = {}
parameters[PlayerOperations.PARAM_GREAT_PERSON_INDIVIDUAL_TYPE] = individualID
parameters[PlayerOperations.PARAM_YIELD_TYPE] = YieldTypes.GOLD
UI.RequestPlayerOperation(playerID, PlayerOperations.PATRONIZE_GREAT_PERSON, parameters)

Patronize faith:
local playerID = Game.GetLocalPlayer()
local parameters = {}
parameters[PlayerOperations.PARAM_GREAT_PERSON_INDIVIDUAL_TYPE] = individualID
parameters[PlayerOperations.PARAM_YIELD_TYPE] = YieldTypes.FAITH
UI.RequestPlayerOperation(playerID, PlayerOperations.PATRONIZE_GREAT_PERSON, parameters)

Import checks to conduct:
Rejecting a great person:
if pGreatPeople:CanRejectPerson(playerID, individualID) then
    -- Get rejection cost
    local rejectCost = pGreatPeople:GetRejectCost(playerID, individualID)
    -- Safe to reject if player can afford cost
end
Recruit a great person:
local pGreatPeople = Game.GetGreatPeople()
-- Check if can recruit
if pGreatPeople:CanRecruitPerson(playerID, individualID) then
    -- Get recruitment cost 
    local recruitCost = pGreatPeople:GetRecruitCost(playerID, individualID)
    -- Safe to recruit if player can afford cost
end


Patronage of great people:
-- For Gold
if pGreatPeople:CanPatronizePerson(playerID, individualID, YieldTypes.GOLD) then
    local goldCost = pGreatPeople:GetPatronizeCost(playerID, individualID, YieldTypes.GOLD)
    -- Safe to patronize if player can afford cost
end

-- For Faith  
if pGreatPeople:CanPatronizePerson(playerID, individualID, YieldTypes.FAITH) then
    local faithCost = pGreatPeople:GetPatronizeCost(playerID, individualID, YieldTypes.FAITH)
    -- Safe to patronize if player can afford cost 
end


The code also shows how to get important information about Great People:
Get currently available people: Game.GetGreatPeople():GetTimeline()
Get previously recruited people: Game.GetGreatPeople():GetPastTimeline()
Get points earned per class: player:GetGreatPeoplePoints():GetPointsTotal(classID)
Get points per turn per class: player:GetGreatPeoplePoints():GetPointsPerTurn(classID)
Get ability effects/actions: Access ActionNameText, ActionEffectText, PassiveNameText, PassiveEffectText from person data
Get recruitment requirements/costs: pGreatPeople:GetEarnConditionsText(playerID, individualID)
Get other player’s progress on great people: 
local pointsTable = {}
local players = Game.GetPlayers{Major = true, Alive = true}
for i, player in ipairs(players) do
    -- Get points data for each player for each class
    local playerPoints = {
        MaxPlayerInstances = classInfo.MaxPlayerInstances,
        NumInstancesEarned = pGreatPeople:CountPeopleReceivedByPlayer(classID, player:GetID()),
        PointsTotal = player:GetGreatPeoplePoints():GetPointsTotal(classID),
        PointsPerTurn = player:GetGreatPeoplePoints():GetPointsPerTurn(classID),
        PlayerID = player:GetID()
    }
    table.insert(pointsTable, playerPoints)
end

Research: 
local pPlayer = Players[Game.GetLocalPlayer()]
local playerTechs = pPlayer:GetTechs()

-- Check if can research this tech
if playerTechs:CanResearch(techID) then
    -- Get research cost
    local cost = playerTechs:GetResearchCost(techID)
    
    -- Check if already researched
    if not playerTechs:HasTech(techID) then
        -- Get progress if partially researched
        local progress = playerTechs:GetResearchProgress(techID)
        
        -- Get turns remaining
        local turnsLeft = playerTechs:GetTurnsLeft()
        
        -- Check if boosted
        local isBoosted = playerTechs:HasBoostBeenTriggered(techID)
        
        -- Safe to research
    end
end


Research info:
-- Get currently researching tech
local currentTechID = playerTechs:GetResearchingTech()

-- Get full research queue
local queue = {}
playerTechs:GetResearchQueue(queue)

-- Get tech yields
local scienceYield = playerTechs:GetScienceYield()

-- Get AI recommendations
local pGrandAI = player:GetGrandStrategicAI()
local recommendations = pGrandAI:GetTechRecommendations()

-- Get unlock info
local unlockables = GetUnlockablesForTech_Cached(techType, playerID)

-- Get prerequisites
local prereqs = GameInfo.TechnologyPrereqs()

Queue a technology path:
local playerID = Game.GetLocalPlayer()
local playerTechs = Players[playerID]:GetTechs()

-- Get path to desired tech 
local techPath = playerTechs:GetResearchPath(targetTechHash)

-- Queue up the full path
local params = {}
params[PlayerOperations.PARAM_TECH_TYPE] = techPath
params[PlayerOperations.PARAM_INSERT_MODE] = PlayerOperations.VALUE_EXCLUSIVE -- or VALUE_APPEND to add to existing queue

UI.RequestPlayerOperation(playerID, PlayerOperations.RESEARCH, params)

Select a unit:
-- Select a single unit  
UI.SelectUnit(unit)

-- Deselect all units and cities
UI.DeselectAllUnits()
UI.DeselectAllCities()

-- Get currently selected unit
UI.GetHeadSelectedUnit()

Unit movement commands: 
local parameters = {}
parameters[UnitOperationTypes.PARAM_X] = x  -- target x coordinate
parameters[UnitOperationTypes.PARAM_Y] = y  -- target y coordinate
parameters[UnitOperationTypes.PARAM_MODIFIERS] = UnitOperationMoveModifiers.ATTACK -- Optional modifier for attack moves

-- Check if unit can perform move
if UnitManager.CanStartOperation(unit, UnitOperationTypes.MOVE_TO, nil, parameters) then
    -- Execute move
    UnitManager.RequestOperation(unit, UnitOperationTypes.MOVE_TO, parameters)
end

-- For attacks
if UnitManager.CanStartOperation(unit, UnitOperationTypes.RANGE_ATTACK, nil, parameters) then
    UnitManager.RequestOperation(unit, UnitOperationTypes.RANGE_ATTACK, parameters)
end

Unit Information:
local unit = player:GetUnits():FindID(unitID)

-- Get unit position
local x = unit:GetX()
local y = unit:GetY() 

-- Check unit stats
local damage = unit:GetDamage()
local maxDamage = unit:GetMaxDamage()
local healthPercent = (maxDamage - damage) / maxDamage

-- Check movement points
local hasMovesLeft = unit:IsReadyToMove()

-- Get first unit with remaining moves
local firstReadyUnit = player:GetUnits():GetFirstReadyUnit()

-- Check formation/combat abilities
local canRangeAttack = unit:GetRangedCombat() > 0
local isMilitary = unit:GetCombat() > 0
local formation = unit:GetMilitaryFormation()

-- Get unit type info
local unitType = GameInfo.Units[unit:GetUnitType()]
local unitDomain = unitType.Domain -- 'DOMAIN_LAND', 'DOMAIN_SEA', etc

Check unit status: 
local activityType = UnitManager.GetActivityType(unit)
-- Can check against:
-- ActivityTypes.ACTIVITY_SLEEP
-- ActivityTypes.ACTIVITY_HOLD
-- ActivityTypes.ACTIVITY_AWAKE
-- ActivityTypes.ACTIVITY_HEAL
-- ActivityTypes.NO_ACTIVITY

Send a trade route:
-- To select a trader unit:
UI.SelectUnit(traderUnit)

-- To start a trade route to a destination city:
local operationParams = {};
operationParams[UnitOperationTypes.PARAM_X0] = destinationCity:GetX();
operationParams[UnitOperationTypes.PARAM_Y0] = destinationCity:GetY(); 
operationParams[UnitOperationTypes.PARAM_X1] = selectedUnit:GetX();
operationParams[UnitOperationTypes.PARAM_Y1] = selectedUnit:GetY();

UnitManager.RequestOperation(selectedUnit, UnitOperationTypes.MAKE_TRADE_ROUTE, operationParams);
Function to send trade route:
function EstablishTradeRoute(originCityID, destinationCityID)
    -- Get the cities
    local originCity = Cities.FindID(originCityID)
    local destinationCity = Cities.FindID(destinationCityID)
    
    -- Find an available trader in the origin city
    local traderUnit = GetTraderInCity(originCity)
    if not traderUnit then
        return false
    end
    
    -- Select the trader
    UI.SelectUnit(traderUnit)
    
    -- Set up and request the trade route
    local params = {}
    params[UnitOperationTypes.PARAM_X0] = destinationCity:GetX()
    params[UnitOperationTypes.PARAM_Y0] = destinationCity:GetY()
    params[UnitOperationTypes.PARAM_X1] = traderUnit:GetX() 
    params[UnitOperationTypes.PARAM_Y1] = traderUnit:GetY()
    
    return UnitManager.RequestOperation(traderUnit, UnitOperationTypes.MAKE_TRADE_ROUTE, params)
end

-- Helper function to find trader in city
function GetTraderInCity(city)
    local units = city:GetUnits()
    for i, unit in units:Members() do
        if unit:GetUnitType() == GameInfo.Units["UNIT_TRADER"].Index then
            return unit
        end
    end
    return nil
end
-- Example usage
local success = EstablishTradeRoute(originCityID, destinationCityID)

Agent example for trade route selection, but its in python : 
class TradeRouteAgent:
    def evaluate_route_yields(self, route_info):
        """
        Evaluates total yields for both origin and destination cities for a trade route
        Returns a combined dictionary of all yields
        """
        # The yield indices are 0-based and represent:
        # 0: FOOD
        # 1: PRODUCTION 
        # 2: GOLD
        # 3: SCIENCE
        # 4: CULTURE
        # 5: FAITH

        # Get yields for origin city
        origin_yields = Game.GetTradeManager():CalculateOriginYieldsFromPotentialRoute(
            route_info.OriginCityPlayer,
            route_info.OriginCityID,
            route_info.DestinationCityPlayer,
            route_info.DestinationCityID
        )
        
        # Get yields for destination city
        destination_yields = Game.GetTradeManager():CalculateDestinationYieldsFromPotentialRoute(
            route_info.OriginCityPlayer,
            route_info.OriginCityID,
            route_info.DestinationCityPlayer,
            route_info.DestinationCityID
        )

        # Create structured yield data
        yields = {
            "origin": {
                "food": origin_yields[1],
                "production": origin_yields[2],
                "gold": origin_yields[3], 
                "science": origin_yields[4],
                "culture": origin_yields[5],
                "faith": origin_yields[6]
            },
            "destination": {
                "food": destination_yields[1],
                "production": destination_yields[2],
                "gold": destination_yields[3],
                "science": destination_yields[4], 
                "culture": destination_yields[5],
                "faith": destination_yields[6]
            }
        }

        return yields

    def calculate_route_value(self, yields):
        """
        Calculate overall value of a trade route based on its yields
        Agent can be trained to optimize these weights
        """
        # Example weights - these would be learned by the agent
        weights = {
            "food": 1.0,
            "production": 1.2,
            "gold": 1.5,
            "science": 1.3,
            "culture": 1.1,
            "faith": 0.8
        }

        value = 0
        # Sum weighted yields from both origin and destination
        for city_type in ["origin", "destination"]:
            for yield_type, yield_amount in yields[city_type].items():
                value += yield_amount * weights[yield_type]

        return value

    def select_best_trade_route(self, available_routes):
        """
        Evaluates all available routes and selects the best one
        """
        best_route = None
        best_value = float('-inf')

        for route in available_routes:
            yields = self.evaluate_route_yields(route)
            route_value = self.calculate_route_value(yields)
            
            if route_value > best_value:
                best_value = route_value
                best_route = route

        return best_route

Performing unit actions:
move:
function QueueUnitMovement(unit, plotX, plotY)
    if unit == nil then return false end
    
    local tParameters = {};
    tParameters[UnitOperationTypes.PARAM_X] = plotX;
    tParameters[UnitOperationTypes.PARAM_Y] = plotY;
    
    -- Validation: Check if unit can move to target plot
    if (UnitManager.CanStartOperation(unit, UnitOperationTypes.MOVE_TO, nil, tParameters)) then
        UnitManager.RequestOperation(unit, UnitOperationTypes.MOVE_TO, tParameters);
        return true;
    end
    return false;
end

Range attack:
function UnitRangeAttack(unit, targetPlotID)
    if unit == nil or (not Map.IsPlot(targetPlotID)) then return false end
    
    local plot = Map.GetPlotByIndex(targetPlotID);
    local tParameters = {};
    tParameters[UnitOperationTypes.PARAM_X] = plot:GetX();
    tParameters[UnitOperationTypes.PARAM_Y] = plot:GetY();

    -- Validation: Check if unit can perform ranged attack
    if UnitManager.CanStartOperation(unit, UnitOperationTypes.RANGE_ATTACK, nil, tParameters) then
        UnitManager.RequestOperation(unit, UnitOperationTypes.RANGE_ATTACK, tParameters);
        return true;
    end
    return false;
end

Air attack:
function UnitAirAttack(unit, targetPlotID)
    if unit == nil or (not Map.IsPlot(targetPlotID)) then return false end
    
    local plot = Map.GetPlotByIndex(targetPlotID);
    local tParameters = {};
    tParameters[UnitOperationTypes.PARAM_X] = plot:GetX();
    tParameters[UnitOperationTypes.PARAM_Y] = plot:GetY();

    -- Additional validation for war declaration
    local bWillStartWar = false;
    local results = CombatManager.IsAttackChangeWarState(unit:GetComponentID(), plot:GetX(), plot:GetY());
    if results and #results > 0 then
        bWillStartWar = true;
        -- Handle war declaration through dialog/events
        return false;
    end

    if UnitManager.CanStartOperation(unit, UnitOperationTypes.AIR_ATTACK, nil, tParameters) then
        UnitManager.RequestOperation(unit, UnitOperationTypes.AIR_ATTACK, tParameters);
        return true;
    end
    return false;
End
Unit formation:
function FormUnitFormation(unit, targetUnit, formationType)
    if unit == nil or targetUnit == nil then return false end
    
    local tParameters = {};
    tParameters[UnitCommandTypes.PARAM_UNIT_PLAYER] = targetUnit:GetOwner();
    tParameters[UnitCommandTypes.PARAM_UNIT_ID] = targetUnit:GetID();
    
    local operationType = (formationType == "CORPS") and 
        UnitCommandTypes.FORM_CORPS or UnitCommandTypes.FORM_ARMY;
    
    if UnitManager.CanStartCommand(unit, operationType, tParameters) then
        UnitManager.RequestCommand(unit, operationType, tParameters);
        return true;
    end
    return false;
end

Rebase:
function UnitRebase(unit, targetPlotID)
    if unit == nil or (not Map.IsPlot(targetPlotID)) then return false end
    
    local plot = Map.GetPlotByIndex(targetPlotID);
    local tParameters = {};
    tParameters[UnitOperationTypes.PARAM_X] = plot:GetX();
    tParameters[UnitOperationTypes.PARAM_Y] = plot:GetY();
    
    if UnitManager.CanStartOperation(unit, UnitOperationTypes.REBASE, nil, tParameters) then
        UnitManager.RequestOperation(unit, UnitOperationTypes.REBASE, tParameters);
        return true;
    end
    return false;
End
Nuclear strike:
function UnitWMDStrike(unit, targetPlotID, wmdType)
    if unit == nil or (not Map.IsPlot(targetPlotID)) then return false end
    
    local plot = Map.GetPlotByIndex(targetPlotID);
    local tParameters = {};
    tParameters[UnitOperationTypes.PARAM_X] = plot:GetX();
    tParameters[UnitOperationTypes.PARAM_Y] = plot:GetY();
    tParameters[UnitOperationTypes.PARAM_WMD_TYPE] = wmdType;
    
    -- Additional validation for war declaration
    local bWillStartWar = false;
    local results = CombatManager.IsAttackChangeWarState(unit:GetComponentID(), plot:GetX(), plot:GetY(), wmdType);
    if results and #results > 0 then
        bWillStartWar = true;
        -- Handle war declaration through dialog/events
        return false;
    end
    
    if UnitManager.CanStartOperation(unit, UnitOperationTypes.WMD_STRIKE, nil, tParameters) then
        UnitManager.RequestOperation(unit, UnitOperationTypes.WMD_STRIKE, tParameters);
        return true;
    end
    return false;
end
Path queueing:
function QueueUnitPath(unit, plotID)
    if unit == nil or (not Map.IsPlot(plotID)) then return false end
    
    local plot = Map.GetPlotByIndex(plotID);
    local pathPlots, turnsList = UnitManager.GetMoveToPath(unit, plotID);
    
    if pathPlots and #pathPlots > 0 then
        local tParameters = {};
        tParameters[UnitOperationTypes.PARAM_X] = plot:GetX();
        tParameters[UnitOperationTypes.PARAM_Y] = plot:GetY();
        
        if UnitManager.CanStartOperation(unit, UnitOperationTypes.MOVE_TO, nil, tParameters) then
            UnitManager.RequestOperation(unit, UnitOperationTypes.MOVE_TO, tParameters);
            return true;
        end
    end
    return false;
end
Build improvement:
function RequestBuildImprovement(unit, improvementHash)
  if unit == nil then return false end
  
  local tParameters = {
    [UnitOperationTypes.PARAM_X] = unit:GetX(),
    [UnitOperationTypes.PARAM_Y] = unit:GetY(),
    [UnitOperationTypes.PARAM_IMPROVEMENT_TYPE] = improvementHash
  };

  -- Validation: Check if unit can build this improvement
  if UnitManager.CanStartOperation(unit, UnitOperationTypes.BUILD_IMPROVEMENT, nil, tParameters) then
    UnitManager.RequestOperation(unit, UnitOperationTypes.BUILD_IMPROVEMENT, tParameters);
    return true;
  end
  return false;
end
Enter formation:
function RequestEnterFormation(selectedUnit, targetUnit) 
  if selectedUnit == nil or targetUnit == nil then return false end

  local tParameters = {
    [UnitCommandTypes.PARAM_UNIT_PLAYER] = targetUnit:GetOwner(),
    [UnitCommandTypes.PARAM_UNIT_ID] = targetUnit:GetID()
  };

  -- Validation: Check if units can form up
  if UnitManager.CanStartCommand(selectedUnit, UnitCommandTypes.ENTER_FORMATION, nil, tParameters) then
    UnitManager.RequestCommand(selectedUnit, UnitCommandTypes.ENTER_FORMATION, tParameters);
    return true;
  end 
  return false;
end
Found city: 
function RequestFoundCity(unit)
  if unit == nil then return false end 

  -- Simple validation: Check if unit can found city here
  if UnitManager.CanStartOperation(unit, UnitOperationTypes.FOUND_CITY, nil) then
    UnitManager.RequestOperation(unit, UnitOperationTypes.FOUND_CITY);
    
    -- Clean up any water availability UI lens
    if UILens.IsLayerOn(LensLayers.HEX_COLORING_WATER_AVAILABLITY) then
      UILens.ToggleLayerOff(LensLayers.HEX_COLORING_WATER_AVAILABLITY);
    end
    UILens.SetActive("Default");
    return true;
  end
  return false;
end
Promote unit:
function RequestPromoteUnit(unit, promotionHash)
  if unit == nil then return false end

  local tParameters = {
    [UnitCommandTypes.PARAM_PROMOTION_TYPE] = promotionHash
  };

  -- Validation: Check if unit can receive this promotion
  if UnitManager.CanStartCommand(unit, UnitCommandTypes.PROMOTE, nil, tParameters) then
    UnitManager.RequestCommand(unit, UnitCommandTypes.PROMOTE, tParameters);
    return true;
  end
  return false;
end

-- Helper function to get available promotions
function GetAvailablePromotions(unit)
  if unit == nil then return nil end

  -- Request promotion list from engine
  local bCanStart, tResults = UnitManager.CanStartCommand(
    unit, 
    UnitCommandTypes.PROMOTE, 
    true,  -- Test mode 
    nil,   -- Parameters
    true   -- Get results
  );

  if bCanStart and tResults then
    return tResults[UnitCommandResults.PROMOTIONS];
  end
  return nil;
end
Delete unit:
function RequestDeleteUnit(unit)
  if unit == nil then return false end

  -- Validation: Check if unit can be deleted  
  if UnitManager.CanStartCommand(unit, UnitCommandTypes.DELETE, true) then
    UnitManager.RequestCommand(unit, UnitCommandTypes.DELETE);

    -- Clean up any active lenses
    if UILens.IsLayerOn(LensLayers.HEX_COLORING_WATER_AVAILABLITY) then
      UILens.ToggleLayerOff(LensLayers.HEX_COLORING_WATER_AVAILABLITY);
    elseif UILens.IsLayerOn(LensLayers.HEX_COLORING_GREAT_PEOPLE) then
      UILens.ToggleLayerOff(LensLayers.HEX_COLORING_GREAT_PEOPLE);
    end
    UILens.SetActive("Default");
    return true;
  end
  return false;
end

-- Helper function to prompt user before deleting
function PromptDeleteUnit(unit)
  if unit == nil then return end

  -- Only show prompt if deletion is possible
  if UnitManager.CanStartCommand(unit, UnitCommandTypes.DELETE, true) then
    local unitName = GameInfo.Units[unit:GetUnitType()].Name;
    local msg = Locale.Lookup("LOC_HUD_UNIT_PANEL_ARE_YOU_SURE_DELETE", unitName); 
    
    local popup = PopupDialogInGame:new("UnitPanelPopup");
    popup:ShowYesNoDialog(
      msg,
      function() RequestDeleteUnit(unit) end,  -- On Yes
      function() end                         -- On No
    );
  end
end
USE EXAMPLES:
-- Build a farm
RequestBuildImprovement(selectedUnit, GameInfo.Improvements["IMPROVEMENT_FARM"].Hash);

-- Form units up
RequestEnterFormation(selectedUnit, targetUnit);

-- Found a city
RequestFoundCity(selectedUnit);

-- Promote with specific promotion
RequestPromoteUnit(selectedUnit, availablePromotion.Hash);

-- Delete after confirmation
PromptDeleteUnit(selectedUnit);

Request a unit upgrade:
-- Main function to request unit upgrade
function RequestUnitUpgrade(unit)
  if unit == nil then return false end

  -- Basic validation first
  if UnitManager.CanStartCommand(unit, UnitCommandTypes.UPGRADE, true) then
    -- Detailed validation with results
    local bCanStartNow, tResults = UnitManager.CanStartCommand(unit, UnitCommandTypes.UPGRADE, false, true);
    
    if bCanStartNow then
      UnitManager.RequestCommand(unit, UnitCommandTypes.UPGRADE);
      return true;
    end
  end
  return false;
end

-- Get upgrade info for a unit, returns nil if upgrade not possible
function GetUnitUpgradeInfo(unit)
  if unit == nil then return nil end

  local upgradeInfo = {
    canUpgrade = false,
    upgradeTo = nil,
    upgradeCost = 0,
    failureReasons = {},
    tooltip = ""
  };

  -- Check if upgrade is even possible
  if not UnitManager.CanStartCommand(unit, UnitCommandTypes.UPGRADE, true) then
    return nil;
  end

  -- Get detailed results
  local bCanStartNow, tResults = UnitManager.CanStartCommand(unit, UnitCommandTypes.UPGRADE, false, true);
  
  if tResults then
    -- Get upgrade unit info
    local upgradeUnitType = tResults[UnitOperationResults.UNIT_TYPE];
    if upgradeUnitType then
      local upgradeUnit = GameInfo.Units[upgradeUnitType];
      upgradeInfo.upgradeTo = upgradeUnit;
      upgradeInfo.canUpgrade = bCanStartNow;
      upgradeInfo.upgradeCost = unit:GetUpgradeCost();
      
      -- Build tooltip
      local tooltip = Locale.Lookup("LOC_UNITOPERATION_UPGRADE_DESCRIPTION");
      tooltip = tooltip .. " " .. Locale.Lookup(upgradeUnit.Name);
      
      if upgradeInfo.upgradeCost then
        tooltip = Locale.Lookup(
          "LOC_UNITOPERATION_UPGRADE_INFO", 
          upgradeUnit.Name,
          upgradeInfo.upgradeCost
        );
      end

      -- Add failure reasons if any
      if tResults[UnitOperationResults.FAILURE_REASONS] then
        for i,reason in ipairs(tResults[UnitOperationResults.FAILURE_REASONS]) do
          table.insert(upgradeInfo.failureReasons, reason);
          tooltip = tooltip .. "[NEWLINE]" .. "[COLOR:Red]" .. Locale.Lookup(reason) .. "[ENDCOLOR]";
        end
      end

      upgradeInfo.tooltip = tooltip;
    end
  end

  return upgradeInfo;
end

-- Just try to upgrade RequestUnitUpgrade(selectedUnit); -- Get upgrade info for display/checking local upgradeInfo = GetUnitUpgradeInfo(selectedUnit); if upgradeInfo and upgradeInfo.canUpgrade then print("Can upgrade to " .. upgradeInfo.upgradeTo.Name .. " for " .. upgradeInfo.upgradeCost .. " gold"); end

Change government:
-- To change to a new government, use RequestPlayerOperation
local playerID = Game.GetLocalPlayer()
local parameters = {}
parameters[PlayerOperations.PARAM_GOVERNMENT_TYPE] = governmentHash -- The hash of the government type
UI.RequestPlayerOperation(playerID, PlayerOperations.CHANGE_GOVERNMENT, parameters)

-- Example of changing to Autocracy:
local autocracyHash = GameInfo.Governments["GOVERNMENT_AUTOCRACY"].Hash
local parameters = {}
parameters[PlayerOperations.PARAM_GOVERNMENT_TYPE] = autocracyHash
UI.RequestPlayerOperation(playerID, PlayerOperations.CHANGE_GOVERNMENT, parameters)

Change policy cards:
-- To change policy cards, you need to:
-- 1. Build lists of slots to clear and policies to add
-- 2. Use RequestPolicyChanges to apply the changes

local playerID = Game.GetLocalPlayer()
local player = Players[playerID]
local playerCulture = player:GetCulture()

-- Create lists for policy changes
local clearList = {} -- Slots to clear
local addList = {}  -- New policies to add, keyed by slot index

-- Example: Clear slot 0 and add a new military policy
table.insert(clearList, 0)  -- Clear slot 0
addList[0] = GameInfo.Policies["POLICY_MILITARY_FIRST"].Hash

-- Apply the changes
playerCulture:RequestPolicyChanges(clearList, addList)

-- More complete example showing multiple policy changes:
local function ChangePolicies(policyChanges)
    local clearList = {}
    local addList = {}
    
    -- Build clear and add lists
    for slot, policyType in pairs(policyChanges) do
        table.insert(clearList, slot)
        addList[slot] = GameInfo.Policies[policyType].Hash
    end
    
    -- Request the changes
    playerCulture:RequestPolicyChanges(clearList, addList)
end

-- Usage example:
local changes = {
    [0] = "POLICY_MILITARY_FIRST",    -- Military slot
    [1] = "POLICY_DIPLOMATIC_LEAGUE", -- Diplomatic slot
    [2] = "POLICY_URBAN_PLANNING"     -- Economic slot
}
ChangePolicies(changes)

Check if changes are possible: 
local function CanChangeGovernment()
    local playerID = Game.GetLocalPlayer()
    local player = Players[playerID]
    local playerCulture = player:GetCulture()
    
    -- Check if government change is possible
    if playerCulture:CanChangeGovernmentAtAll() and
       not playerCulture:GovernmentChangeMade() and
       Game.IsAllowStrategicCommands(playerID) then
        return true
    end
    return false
end

local function CanChangePolicies()
    local playerID = Game.GetLocalPlayer()
    local player = Players[playerID]
    local playerCulture = player:GetCulture()
    
    -- Check if policy changes are possible
    if (playerCulture:CivicCompletedThisTurn() or 
        playerCulture:GetNumPolicySlotsOpen() > 0) and
        Game.IsAllowStrategicCommands(playerID) and 
        playerCulture:PolicyChangeMade() == false then
        return true
    end
    return false
end
Example:
function ApplyNewGovernmentAndPolicies(governmentType, policyChanges)
    local playerID = Game.GetLocalPlayer()
    local player = Players[playerID]
    local playerCulture = player:GetCulture()
    
    -- First change government if possible
    if CanChangeGovernment() then
        local governmentHash = GameInfo.Governments[governmentType].Hash
        local parameters = {}
        parameters[PlayerOperations.PARAM_GOVERNMENT_TYPE] = governmentHash
        UI.RequestPlayerOperation(playerID, PlayerOperations.CHANGE_GOVERNMENT, parameters)
    end
    
    -- Then change policies if possible
    if CanChangePolicies() then
        local clearList = {}
        local addList = {}
        
        for slot, policyType in pairs(policyChanges) do
            table.insert(clearList, slot)
            addList[slot] = GameInfo.Policies[policyType].Hash
        end
        
        playerCulture:RequestPolicyChanges(clearList, addList)
    end
end

-- Usage example:
local newGovernment = "GOVERNMENT_AUTOCRACY"
local newPolicies = {
    [0] = "POLICY_MILITARY_FIRST",
    [1] = "POLICY_DIPLOMATIC_LEAGUE",
    [2] = "POLICY_URBAN_PLANNING"
}
ApplyNewGovernmentAndPolicies(newGovernment, newPolicies)



